# Copilot Instructions (Generated)

## Overview
This document enables AI coding assistants (e.g., GitHub Copilot Chat) to operate consistently with the prompt workflows in this repository. It is compiled only from actual repository artifacts found in `understanding-code/instruction-generation` and related prompt suites. Do not treat any guidance here as normative for external projects unless the target project is explicitly analyzed and artifacts are produced under the configured `{output_folder}` (default: `.results/`).

## File Category Reference
The repository organizes prompts and templates into the following categories (examples):

- **repo-overview:** `./README.md` — high-level repo purpose and usage guidance for Copilot + MCP.
- **governance:** `./CONTRIBUTING.md`, `./LICENSE` — contribution flow and licensing.
- **repo-config:** `./.gitignore`, `./.vscode/mcp.json` — MCP server registration; use `stdio` or HTTP endpoints.
- **utility-prompts:** `./crop-image/crop-image.md` — small, parameterized utilities with stepwise instructions.
- **instruction-generation-chain:** `./understanding-code/instruction-generation/*` — six-step chain that produces `.results/*` artifacts.
- **jira-feature-chain:** `./writing-code/generate-feature/*` — ticket-driven implementation flow starting from `{TICKET_NUMBER}`.
- **story-from-figma-chain & templates:** `./writing-stories/from-figma/*` — screens -> analysis -> shell stories -> full stories; templates include `shell-story-template.md` and `nested-gherkin.md`.
- **story-from-images-chain & templates:** `./writing-stories/from-images/*` — same output contract but starts with manual screenshots.

For full category-to-file mappings, see `.results/2-file-categorization.json` generated by the instruction-generation chain.

## Feature Scaffold Guide
When asked to scaffold a feature for an external project, follow this sequence:

1. Determine target project context (run the `instruction-generation` chain against that repository or provide a prefilled `.results/1-determine-techstack.md`).
2. Identify which categories are required for the feature (e.g., UI components, hooks, API clients). Use `.results/2-file-categorization.json` to map categories to canonical examples.
3. Place new files according to observed patterns:
   - Prompts and templates remain in the prompt repo; generated code should go to the target project.
   - For story outputs, artifacts live under `.results/stories` when generating from designs.
4. Naming and structure:
   - Use kebab-case for screen names in `screens.yaml`.
   - Follow templates for story output (shell story -> full story with nested Gherkin).
5. Example scaffold for a UI component (only as a guideline if target project supports similar patterns):
   - `src/components/FeatureName.tsx` (or equivalent in the target project)
   - `src/components/FeatureName.module.css` if styles are colocated
   - `src/hooks/useFeatureName.ts` if local hooks are needed
   - `tests/FeatureName.test.ts` for basic unit tests

Note: This repo contains no application source code. Always run the instruction chain against the actual target repository to extract concrete file categories and style guides before generating files.

## Integration Rules
Derived from `.results/3-architectural-domains.json` and per-domain style files:

- **Strict sequencing:** The instruction-generation chain expects artifacts to be written in order to `./{output_folder}` which later steps will read exactly by name.
- **Evidence-first:** All claims about a codebase must reference concrete files and paths produced by the analysis; avoid speculation.
- **MCP requirement:** Workflows that depend on external systems (Jira, Figma, attachments) require MCP servers configured in `.vscode/mcp.json` and reachable endpoints.
- **Scope-limitation for ticket automation:** When implementing features from a Jira ticket, only implement what is explicitly described and reflected in fetched design assets; do not add unrequested features.
- **Artifact placement:** Generated analysis/story artifacts belong under `.results/` (or another `{output_folder}` you pass), final instruction files should be placed at the configured `{final_output_file}` path (by default `/.github/copilot-instructions.md`).

## Example Prompt Usage
To have Copilot create a story from Figma, follow the repository’s pipeline:

- Step 1: Prepare screens — create `.results/screens/screens.yaml` with frame URLs
- Step 2: Prepare notes — produce `.results/screens/{screen}.notes.md`
- Step 3: Prepare analysis — produce `.results/screens/{screen}.analysis.md`
- Step 4: Analyze screens — enrich analysis files with UI element details
- Step 5: Create shell stories — produce `.results/stories/shell-stories.md`
- Step 6: Write full stories — produce `.results/stories/{story-title}.md` using nested Gherkin

For Jira ticket automation, give Copilot the ticket number and MCP access:

- Input: `{TICKET_NUMBER} = ABC-123`
- Run: `writing-code/generate-feature/generate-feature.md` (agent should fetch the ticket via the Atlassian MCP server, expand Figma links, fetch attachments, then synthesize an implementation plan).

## Where to Look for Source Rules
- File category map: `.results/2-file-categorization.json`
- Architectural domains: `.results/3-architectural-domains.json`
- Per-domain details: `.results/4-domains/*.md`
- Style guides: `.results/5-style-guides/*.md`

---

If you want, I can now:
- Commit these generated `.results/*` artifacts and `/.github/copilot-instructions.md` and push them to `origin/main`.
- Run the full instruction chain against another target repository you provide.

What would you like me to do next?